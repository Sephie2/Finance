import yfinance as yf
import pandas as pd
import numpy as np
import optuna
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick

# --- 1. CONFIGURATION & STARTING VALUES ---
# Zentrale Konfiguration für die Generalisierung
BASE_CONFIG = {
    "SYMBOL_FUTURES": "GC=F",
    "SYMBOL_VOLA": "^GVZ",
    "SYMBOL_LONG_ETF": "3GOL.L",
    "SYMBOL_SHORT_ETF": "3GOS.L",
    "START_DATE": "2020-01-01",
    "MASTER_TREND_RES": "3D",
    "TRIAL_RUNS": 200,
    # Startwerte für die Vortex-Optimierung
    "INIT_VORTEX_PERIOD": 14,
    "INIT_VORTEX_EMA": 5,
    "INIT_ADX_ENTRY": 20,
    "INIT_ADX_EXIT": 18,
    "INIT_VOLA_CRIT": 22.0,
    "INIT_ATR_STD": 4.5,
    "INIT_ATR_TIGHT": 2.5
}

# --- 2. GLOBAL DATA LOADING ---
raw_data = yf.download([
    BASE_CONFIG["SYMBOL_FUTURES"], 
    BASE_CONFIG["SYMBOL_VOLA"], 
    BASE_CONFIG["SYMBOL_LONG_ETF"], 
    BASE_CONFIG["SYMBOL_SHORT_ETF"]
], start=BASE_CONFIG["START_DATE"], auto_adjust=True)

df_fut = raw_data.xs(BASE_CONFIG["SYMBOL_FUTURES"], axis=1, level=1).dropna()
df_vola = raw_data['Close'][BASE_CONFIG["SYMBOL_VOLA"]].ffill()
price_long = raw_data['Close'][BASE_CONFIG["SYMBOL_LONG_ETF"]].ffill()
rets_long = price_long.pct_change().fillna(0)
low_long = raw_data['Low'][BASE_CONFIG["SYMBOL_LONG_ETF"]].ffill()

# --- 3. HELPER FUNCTIONS ---
def calculate_vortex(df, period, ema_span):
    h_l = df['High'] - df['Low']
    tr = pd.concat([h_l, abs(df['High']-df['Close'].shift(1)), abs(df['Low']-df['Close'].shift(1))], axis=1).max(axis=1)
    vmp = abs(df['High'] - df['Low'].shift(1))
    vmm = abs(df['Low'] - df['High'].shift(1))
    vi_plus = vmp.rolling(period).sum() / tr.rolling(period).sum()
    vi_minus = vmm.rolling(period).sum() / tr.rolling(period).sum()
    return vi_plus.ewm(span=ema_span, adjust=False).mean(), vi_minus.ewm(span=ema_span, adjust=False).mean()

def calculate_adx(df, period):
    plus_dm = (df['High'].diff()).clip(lower=0)
    minus_dm = (-df['Low'].diff()).clip(lower=0)
    tr = pd.concat([df['High']-df['Low'], abs(df['High']-df['Close'].shift(1)), abs(df['Low']-df['Close'].shift(1))], axis=1).max(axis=1)
    atr = tr.rolling(period).mean()
    p_di = 100 * (plus_dm.rolling(period).mean() / atr)
    m_di = 100 * (minus_dm.rolling(period).mean() / atr)
    dx = 100 * abs(p_di - m_di) / (p_di + m_di)
    return dx.rolling(period).mean()

# --- 4. OBJECTIVE FUNCTION ---
def objective(trial):
    # Search Space Definition
    v_period  = trial.suggest_int("V_PERIOD", 10, 35)
    v_ema     = trial.suggest_int("V_EMA", 3, 15)
    adx_entry = trial.suggest_int("ADX_ENTRY", 15, 30)
    adx_exit  = trial.suggest_int("ADX_EXIT", 12, 22)
    vola_crit = trial.suggest_float("VOLA_CRIT", 15.0, 35.0)
    atr_std   = trial.suggest_float("ATR_STD", 3.0, 6.0)
    atr_tight = trial.suggest_float("ATR_TIGHT", 1.5, 4.0)
    
    # Master Trend Logic
    w_fut = df_fut.resample(BASE_CONFIG["MASTER_TREND_RES"]).agg({'High':'max', 'Low':'min', 'Close':'last'})
    w_vi_p, w_vi_m = calculate_vortex(w_fut, v_period, v_ema)
    master_trend = (w_vi_p > w_vi_m).reindex(df_fut.index, method='ffill').shift(1).fillna(False)
    
    # Daily Logic
    d_vi_p, d_vi_m = calculate_vortex(df_fut, v_period, v_ema)
    d_adx = calculate_adx(df_fut, 14)
    d_atr = pd.concat([df_fut['High']-df_fut['Low'], abs(df_fut['High']-df_fut['Close'].shift(1)), 
                       abs(df_fut['Low']-df_fut['Close'].shift(1))], axis=1).max(axis=1).rolling(14).mean()
    
    cap, equity = 10000.0, [10000.0]
    pos, peak_price, stop_level = 0, 0.0, 0.0
    hebel = 3.0
    
    for i in range(1, len(df_fut)):
        adx_v, atr_v, vola_v = d_adx.iloc[i-1], d_atr.iloc[i-1], df_vola.iloc[i-1]
        m_t, vi_p, vi_m = master_trend.iloc[i-1], d_vi_p.iloc[i-1], d_vi_m.iloc[i-1]
        
        if pos != 0:
            c_low = low_long.iloc[i]
            if (pos == 1 and c_low < stop_level) or (adx_v < adx_exit):
                pos = 0
            elif not (m_t and vi_p > vi_m):
                pos = 0

        if pos == 0 and adx_v > adx_entry:
            if m_t and vi_p > vi_m:
                pos, peak_price = 1, price_long.iloc[i]

        if pos != 0:
            peak_price = max(peak_price, price_long.iloc[i])
            mult = atr_tight if (adx_v > 50 or vola_v > vola_crit) else atr_std
            tsl = min((atr_v * mult / df_fut['Close'].iloc[i]) * hebel, 0.12 * hebel)
            stop_level = peak_price * (1 - tsl)

        cap *= (1 + (rets_long.iloc[i] if pos == 1 else 0))
        equity.append(cap)
    
    eq_ser = pd.Series(equity).pct_change().fillna(0)
    if eq_ser.std() == 0: return -1
    sharpe = (eq_ser.mean() / eq_ser.std()) * np.sqrt(252)
    trial.set_user_attr("final_cap", cap)
    return sharpe

# --- 5. START OPTIMIZATION ---
study = optuna.create_study(direction="maximize")

# Initialer Versuch mit den neuen Variablennamen einreihen
study.enqueue_trial({
    "V_PERIOD": BASE_CONFIG["INIT_VORTEX_PERIOD"],
    "V_EMA": BASE_CONFIG["INIT_VORTEX_EMA"],
    "ADX_ENTRY": BASE_CONFIG["INIT_ADX_ENTRY"],
    "ADX_EXIT": BASE_CONFIG["INIT_ADX_EXIT"],
    "VOLA_CRIT": BASE_CONFIG["INIT_VOLA_CRIT"],
    "ATR_STD": BASE_CONFIG["INIT_ATR_STD"],
    "ATR_TIGHT": BASE_CONFIG["INIT_ATR_TIGHT"]
})

study.optimize(objective, n_trials=BASE_CONFIG["TRIAL_RUNS"])

# --- 6. OUTPUT ---
print(f"\nDeployment-Zusammenfassung: {BASE_CONFIG['SYMBOL_LONG_ETF']}")
print(f"Master-Trend Auflösung: {BASE_CONFIG['MASTER_TREND_RES']}")
print(f"Optimierungsläufe: {BASE_CONFIG['TRIAL_RUNS']}")
print("-" * 30)
print(f"Beste Sharpe Ratio: {study.best_value:.4f}")
print("Beste Parameter:")
for key, value in study.best_params.items():
    print(f"  {key}: {value}")
print(f"Volatility-Threshold (Optimiert): {study.best_params['VOLA_CRIT']:.4f}")
print(f"Maximales Endkapital: {study.best_trial.user_attrs['final_cap']:.2f} EUR")